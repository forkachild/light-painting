.program inmp441_pio
.side_set 2

.define SKIP_CYCLES         31
.define PUBLIC DIN_CYCLES   25
.define PAD_CYCLES          6

.define L_CLK_LO            0b00
.define L_CLK_HI            0b01
.define R_CLK_LO            0b10
.define R_CLK_HI            0b11

; Keeping in mind the 320ns minimum pulse time
.define public HIGHEST_CLOCK_RATE 6410256

.wrap_target
; Left word starts
; Only receive data from Left channel
; 1st bit will be dummy. That's why 25 cycles to
; receive 24 bits of data
LW_BITLOOP:
    in pins, 1          side L_CLK_HI   ; 1 cycle passed
    jmp x--, LW_BITLOOP side L_CLK_LO   ;
LW_SKIP_SETUP:
    set x, PAD_CYCLES   side L_CLK_HI   ; 1 cycle passed

; Since we already consumed 1 extra channel in the
; previous instruction, we only need to pass 6 more
LW_SKIP:
    nop                 side L_CLK_LO   ;
    jmp x--, LW_SKIP    side L_CLK_HI   ; 1 cycle passed

; Right word starts
; Skip the right channel
RW_SKIP_SETUP:
    set x, SKIP_CYCLES  side R_CLK_LO   ;
RW_SKIP:
    nop                 side R_CLK_HI   ; 1 cycle passed
    jmp x--, RW_SKIP    side R_CLK_LO   ;     
    nop                 side R_CLK_HI   ; 1 cycle passed
PUBLIC ENTRY_POINT:
    set x, DIN_CYCLES   side L_CLK_LO   ;
.wrap

% c-sdk {
#include "hardware/clocks.h"
#include "hardware/gpio.h"

static inline void inmp441_pio_program_init(PIO pio, uint sm, uint offset, uint sck_pin, uint ws_pin, uint data_pin) {
    pio_sm_set_consecutive_pindirs(pio, sm, data_pin, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, sck_pin, 2, true);
    
    pio_gpio_init(pio, data_pin);
    pio_gpio_init(pio, sck_pin);
    pio_gpio_init(pio, ws_pin);

    pio_sm_config c = inmp441_pio_program_get_default_config(offset);

    sm_config_set_sideset_pins(&c, sck_pin);
    sm_config_set_in_pins(&c, data_pin);
    sm_config_set_in_shift(&c, false, true, inmp441_pio_DIN_CYCLES);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    sm_config_set_clkdiv(&c, (float)clock_get_hz(clk_sys) / inmp441_pio_HIGHEST_CLOCK_RATE);

    gpio_pull_down(data_pin);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_exec(pio, sm, pio_encode_jmp(offset + inmp441_pio_offset_ENTRY_POINT));
    pio_sm_set_enabled(pio, sm, true);
}

static inline void inmp441_pio_program_deinit(PIO pio, uint sm) {
    pio_sm_set_enabled(pio, sm, false);
    pio_sm_unclaim(pio, sm);
}

%}